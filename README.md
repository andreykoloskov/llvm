# llvm_prac

На данный момент сделал распарсивание с помощью llvm и заготовку куда писать наш алгоритм доступных выражений:

Существующие на данный момент классы:
AvailableExpessionsPass - проход по исходнику с помощью llvm
AvailableExpressions - обработка этого прохода и получение входных данных для алгоритма доступных выражений
Algorithm - заготовка для алгоритма доступных выражений

Как что работает надеюсь понятно по коду.

Общая суть в том, что используется llvm клманда opt, которая позволяет сделать дополнительный проход по файлу,
а наш код подключается к ней в виде динамической библиотеки.

Если скажут, что надо компилить полностью независимую прогу, то наверное это можно будет сделать, но
нужно будет в проект включать часть исходников llvm, что не удобно.

Теперь как запускать.

1) mkdir bin - создаем пустую директорию bin, т.к. в репо она не хочет записываться, а над makefile сейчас не хочу
колдовать, чтобы она там автоматом создавалась.

2) Компиляция динамической библиотеки: команда make, если находишся внутри проекта
Пока не было времени make красиво оформить, так что там внутри все построчно без автоматизации, но работает и ладно.

3) Запуск: ./run.sh test2 - скрипт с параметром - название тестового файла без указания папки test, в котором они находятся
и без указания расширения (в скрипте все что надо подставляется)
Из скрипта видно, что там из си файла компилится llvm бит код, который подается на вход команды opt, которая, в свою очередь,
запускается с нашей библиотекой и все работает.

Дополнительно делаю еще файл с читаемым биткодом llvm (но это чисто для нас, программе он не нужен).

Чтобы все это заработало, должен стоять рабочий llvm со всеми командами, в том числе clang
В Makefile и run.sh надо заменить пути до исходников и бинарников llvm на те, которые у вас.

Теперь по сути сделанного.

Файл рапарсивается: функции->блоки->инструкции->элемены инструкции

Я постарался записать в входные данные класса Algorithm по максимому что смог выдернуть, но не до конца понял все это или нет:
Для каждого элемента из вышеперечисленных я выдернул числовой код. Эти коды корректные, я проверял,
то есть если в одной инструкции возвращается переменная a, имеет какой - то числовой код, то если
она в другом месте используется, то код тот - же. Так что весь алгоритм надо завязывать на эти коды.
Там где получилось, записал еще и имена, они нужны не для алгоритма, а для вывода результатов.
Но понял я понял как выдергивать не везде. Там где переменные из программы, все нормально, но там
где llvm при формировании бит кода делает какие - то промежуточные переменные %0, %1,  т.д., то эти
имена выдернуть не получилось, есть только числовые коды.
Но так как главное эти коды, то как выдергивать имена, можно искать параллельно с работой по алгоритму.

Чтобы было понятно, сделал отладочный вывод, так что по нему будет все видно, когда прогу запустите.

Теперь пара мыслей по алгоритму доступных выражений.
Сам алгоритм реализовать по лекциям будет не сложно, но там он разобран для одной функции, состоящей из нескольких блоков.
Если тестовая прога состоит из одной или нескольких функций, которые выполняются независимо друг от друга, все просто
и не отличается от лекций: каждая функция с ее блоками рассматривается полность отдельно и все.
Но как быть, если есть глобальные переменные, а также из одной функции вызывается другая, и в нее передаются указатели.
Тут очень много подводных камней: возможно надо будет исследовать дерево у всей программы, но опять же в одном месте
могут передаваться указатели, в другом копии.
Блоки в llvm привязаны к конкретной функции, значит надо дополнительно строить дерево функций, чтобы получить общее дерево блоков.
Мне кажется, если по серьезному делать, то это огромное болото из которого мы не вылезем.
Я спрошу в понедельник про консультацию. Так как теперь часть программы сделана, входные данные для алгоритма считываем,
но появились новые вопросы.

В общем как - то так.

----------------------------------------------
10.04.2016
Изменения
1) Добавил src/main.cpp
2) cmake теперь компилирует библиотеку libAvailable_Expressions.so и main
3) run.sh test2 - теперь компилирует только тест в бит код test/test2.bc
4) ./main /puth_to_opt/opt /puth_to_libAvailable_Expressions.so/libAvailable_Expressions.so /puth_to_test/test.bc

Таким образом сейчас полный цикл такой (с моими путями):

Подготовка:
cmake .
make
run.sh test2

Запуск:
./main /home/akoloskov/llvm/bin/bin/opt /home/akoloskov/msu/New/compile/prac_all_new/woof/libAvailable_Expressions.so test/test2.bc

------------------------------------------------
11.06.2016
Изменения
1) Добавил алгоритм (createAvailableExpressions)
2) Добавил отладочный вывод инструкций в gen - kill и алгоритм
3) Добавил отладочный вывод всех шагов алгоритма
   (printDebugAvailableExpressions)
4) Добавил вывод доступных выражений (printAvailableExpressions)
5) Привел к единому стилю (чтобы за 80 символов не выходило, ну и еще
   пару моментов)
6) Начал тестить, но мне показалось, что gen - kill не совсем правильный.
   Сейчас выводится нормально (только много), но можно закомментить
   не нужный вывод или отматывать к началу, в общем надо в ручную определить
   все и сравнить с прогой.


